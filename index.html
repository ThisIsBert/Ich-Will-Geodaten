<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThisIsBert's IchWillGeodaten</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.4/osmtogeojson.js"></script>

    <style>
        body { margin: 0; padding: 0; display: flex; font-family: 'Segoe UI', sans-serif; height: 100vh; background: #f0f2f5; overflow: hidden; }
        #map { flex-grow: 1; height: 100%; }
        #sidebar { width: 420px; display: flex; flex-direction: column; background: white; border-left: 1px solid #ccc; box-shadow: -2px 0 10px rgba(0,0,0,0.1); z-index: 1001; position: relative; }
        .sidebar-header { padding: 20px; border-bottom: 2px solid #eee; }
        .sidebar-content { flex-grow: 1; overflow-y: auto; padding: 15px; }
        
        #loading-overlay { display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.85); z-index: 2000; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 40px; height: 40px; border-radius: 50%; border-left-color: #007bff; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .search-bar { display: flex; gap: 8px; margin-bottom: 12px; }
        .search-bar input { flex: 1; padding: 8px 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 13px; }
        .search-bar button { padding: 8px 12px; border: none; border-radius: 6px; background: #007bff; color: white; font-weight: 600; cursor: pointer; }
        .search-results-select { width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 13px; margin-bottom: 10px; display: none; }
        .export-bar { display: flex; gap: 10px; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; }
        .export-bar button { flex: 1; padding: 10px; border: none; border-radius: 5px; background: #007bff; color: white; font-weight: bold; cursor: pointer; opacity: 0.3; pointer-events: none; transition: 0.2s; }
        .export-bar button.active { opacity: 1; pointer-events: auto; }
        .export-bar button#copyBtn.active { background: #28a745; }

        .object-item { border: 1px solid #ddd; border-radius: 8px; margin-bottom: 10px; padding: 12px; cursor: pointer; font-size: 13px; }
        .object-item.selected { border: 2px solid #ff7800; background: #fff4e6; }
        .object-title { font-weight: bold; color: #333; display: block; margin-bottom: 3px; }
        
        details { font-size: 11px; margin-top: 5px; color: #555; }
        summary { cursor: pointer; color: #007bff; outline: none; }
        .tag-grid { display: grid; grid-template-columns: auto 1fr; gap: 3px 8px; padding: 5px; background: #fefefe; border: 1px solid #eee; margin-top: 5px; }

        .error-hint { color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; padding: 10px; border-radius: 4px; font-size: 11px; margin-top: 10px; display: none; white-space: pre-wrap; }
    </style>
</head>
<body>

<div id="map"></div>
<div id="sidebar">
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Fordere Daten an...</div>
    </div>

    <div class="sidebar-header">
        <div class="search-bar">
            <input id="searchInput" type="text" placeholder="Ort suchen (z. B. Berlin)" />
            <button id="searchBtn">Suchen</button>
        </div>
        <select id="searchResultsSelect" class="search-results-select" aria-label="Suchergebnisse auswählen"></select>
        <div class="export-bar">
            <button id="copyBtn" onclick="doExport('copy')">Kopieren</button>
            <button id="downBtn" onclick="doExport('download')">Download</button>
        </div>
        <div id="status-error" class="error-hint"></div>
    </div>
    
    <div class="sidebar-content" id="results">
        <p style="text-align:center; color: #888;">Klicke in der Karte auf den gewünschten Ort, um Geo-Daten zu laden</p>
    </div>
</div>

<script>
    const map = L.map('map').setView([51.1657, 10.4515], 6); 
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
        attribution: '© OpenStreetMap' 
    }).addTo(map);

    let clickMarker = null, highlightLayer = null, selectedObjectData = null;
    const loader = document.getElementById('loading-overlay');
    const errorBox = document.getElementById('status-error');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const searchResultsSelect = document.getElementById('searchResultsSelect');
    let searchDebounceTimer = null;

    map.on('click', function(e) {
        const { lat, lng } = e.latlng;
        if (clickMarker) map.removeLayer(clickMarker);
        clickMarker = L.circleMarker([lat, lng], { color: 'red', radius: 5, fillOpacity: 0.8 }).addTo(map);
        if (highlightLayer) map.removeLayer(highlightLayer);
        errorBox.style.display = 'none';
        resetSelection();
        fetchObjects(lat, lng);
    });

    function showError(message) {
        errorBox.style.display = 'block';
        errorBox.innerText = message;
    }

    function setLoading(isLoading, message = "Fordere Daten an...") {
        loader.style.display = isLoading ? 'flex' : 'none';
        document.getElementById('loading-text').innerText = message;
    }

    function resetSearchResultsSelect() {
        searchResultsSelect.innerHTML = '';
        searchResultsSelect.style.display = 'none';
    }

    function prepareForNewQuery() {
        resetSelection();
        errorBox.style.display = 'none';
        if (highlightLayer) map.removeLayer(highlightLayer);
        resetSearchResultsSelect();
    }

    function applySearchResult(lat, lon) {
        if (clickMarker) map.removeLayer(clickMarker);
        clickMarker = L.circleMarker([lat, lon], { color: 'red', radius: 5, fillOpacity: 0.8 }).addTo(map);
        map.setView([lat, lon], 16);
        fetchObjects(lat, lon);
    }

    function populateSearchResultsSelect(results) {
        resetSearchResultsSelect();
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = 'Bitte Treffer auswählen...';
        placeholderOption.disabled = true;
        placeholderOption.selected = true;
        searchResultsSelect.appendChild(placeholderOption);

        results.forEach((result, index) => {
            const option = document.createElement('option');
            option.value = `${result.lat},${result.lon}`;
            option.textContent = result.display_name || `Treffer ${index + 1}`;
            searchResultsSelect.appendChild(option);
        });

        searchResultsSelect.style.display = 'block';
    }

    async function searchPlace() {
        const query = searchInput.value.trim();
        if (!query) {
            showError("Bitte gib einen Ort für die Suche ein.");
            return;
        }

        prepareForNewQuery();
        setLoading(true, "Suche Ort...");

        const encodedQuery = encodeURIComponent(query);
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodedQuery}&limit=10`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                if (response.status === 429) {
                    throw new Error("Nominatim ist ausgelastet. Bitte versuche es gleich erneut.");
                }
                throw new Error("Fehler beim Abruf der Suche.");
            }
            const results = await response.json();
            if (!Array.isArray(results) || results.length === 0) {
                showError("Kein Treffer gefunden. Bitte versuche eine präzisere Suche.");
                return;
            }

            const parsedResults = results
                .map((result) => {
                    const latNum = Number(result.lat);
                    const lonNum = Number(result.lon);
                    if (!Number.isFinite(latNum) || !Number.isFinite(lonNum)) return null;
                    return { ...result, lat: latNum, lon: lonNum };
                })
                .filter(Boolean);

            if (parsedResults.length === 0) {
                showError("Ungültige Koordinaten aus der Suche erhalten.");
                return;
            }

            if (parsedResults.length === 1) {
                resetSearchResultsSelect();
                applySearchResult(parsedResults[0].lat, parsedResults[0].lon);
                return;
            }

            populateSearchResultsSelect(parsedResults);
        } catch (err) {
            showError(err.message || "Unbekannter Fehler bei der Suche.");
        } finally {
            setLoading(false);
        }
    }

    function queueSearch() {
        if (searchDebounceTimer) {
            clearTimeout(searchDebounceTimer);
        }
        searchDebounceTimer = setTimeout(() => {
            searchPlace();
        }, 300);
    }

    searchBtn.addEventListener('click', () => {
        queueSearch();
    });

    searchInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
            event.preventDefault();
            queueSearch();
        }
    });

    searchResultsSelect.addEventListener('change', (event) => {
        const value = event.target.value;
        if (!value) return;
        const [latString, lonString] = value.split(',');
        const lat = Number(latString);
        const lon = Number(lonString);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
            showError("Ungültige Koordinaten aus der Auswahl erhalten.");
            return;
        }
        errorBox.style.display = 'none';
        applySearchResult(lat, lon);
    });

    const OVERPASS_ENDPOINT = 'https://overpass-api.de/api/interpreter';
    const BUSY_HINTS = ["Dispatcher_Client", "too busy", "timeout", "rate limit"];
    const REQUEST_TIMEOUT_MS = 120000;
    const MAX_WAIT_SEARCH_MS = 180000;
    const MAX_WAIT_GEOM_MS = 600000;
    const RETRY_BASE_DELAY_MS = 3000;
    const RETRY_MAX_DELAY_MS = 20000;
    const RELATION_GEOM_AREA_THRESHOLD_DEG2 = 1.0;

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function isBusyResponse(text, status) {
        if ([429, 502, 503, 504].includes(status)) return true;
        const lower = text.toLowerCase();
        return BUSY_HINTS.some(hint => lower.includes(hint.toLowerCase()));
    }

    async function fetchOverpassJson(query, options = {}) {
        const {
            maxWaitMs = 180000,
            requestTimeoutMs = REQUEST_TIMEOUT_MS,
            onWaitMessage = () => {}
        } = options;
        const start = Date.now();
        let attempt = 0;

        while (true) {
            const elapsed = Date.now() - start;
            if (elapsed >= maxWaitMs) {
                throw new Error("Die Abfrage dauert zu lange und wurde abgebrochen.");
            }
            const remainingMs = maxWaitMs - elapsed;
            attempt += 1;
            const controller = new AbortController();
            const effectiveTimeoutMs = Math.min(requestTimeoutMs, remainingMs);
            const timeoutId = setTimeout(() => controller.abort(), effectiveTimeoutMs);
            let text = '';
            let status = 0;

            try {
                const response = await fetch(OVERPASS_ENDPOINT, {
                    method: 'POST',
                    body: new URLSearchParams({ data: query }),
                    signal: controller.signal
                });
                status = response.status;
                text = await response.text();
            } catch (err) {
                if (Date.now() - start >= maxWaitMs) {
                    throw new Error("Die Abfrage dauert zu lange und wurde abgebrochen.");
                }
                const waitMs = Math.min(RETRY_BASE_DELAY_MS * attempt, RETRY_MAX_DELAY_MS);
                onWaitMessage(`Verbindung unterbrochen. Warte ${Math.round(waitMs / 1000)}s...`);
                await sleep(Math.min(waitMs, maxWaitMs - (Date.now() - start)));
                continue;
            } finally {
                clearTimeout(timeoutId);
            }

            try {
                return JSON.parse(text);
            } catch (err) {
                if (isBusyResponse(text, status)) {
                    if (Date.now() - start >= maxWaitMs) {
                        throw new Error("Die Abfrage dauert zu lange und wurde abgebrochen.");
                    }
                    const waitMs = Math.min(RETRY_BASE_DELAY_MS * attempt, RETRY_MAX_DELAY_MS);
                    onWaitMessage(`Server beschäftigt. Warte ${Math.round(waitMs / 1000)}s...`);
                    await sleep(Math.min(waitMs, maxWaitMs - (Date.now() - start)));
                    continue;
                }
                const cleanError = text.replace(/<\/?[^>]+(>|$)/g, "").trim();
                throw new Error("Server-Fehler:\n" + cleanError.substring(0, 200));
            }
        }
    }

    async function fetchObjects(lat, lon) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = `<p style="text-align:center;">Suche...</p>`;
        const query = `[out:json][timeout:60]; ( nwr(around:45, ${lat}, ${lon}); is_in(${lat}, ${lon})->.a; nwr(pivot.a); ); out tags center;`;

        try {
            const data = await fetchOverpassJson(query, {
                maxWaitMs: MAX_WAIT_SEARCH_MS,
                onWaitMessage: (msg) => {
                    resultsDiv.innerHTML = `<p style="text-align:center;">${msg}</p>`;
                }
            });
            const elements = (data.elements || []).filter(el => el.tags);
            if (elements.length === 0) { resultsDiv.innerHTML = "Nichts gefunden."; return; }
            renderList(elements);
        } catch (err) {
            resultsDiv.innerHTML = "Fehler beim Laden der Liste.";
            errorBox.style.display = 'block';
            errorBox.innerText = err.message;
        }
    }

    function renderList(elements) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';
        elements.forEach(el => {
            const t = el.tags;
            const name = t.name || t.highway || t.amenity || t.building || t.boundary || `ID: ${el.id}`;
            const item = document.createElement('div');
            item.className = 'object-item';
            item.innerHTML = `<span class="object-title">[${el.type.toUpperCase()}] ${name}</span>
                <details><summary>Mehr Info</summary><div class="tag-grid">
                ${Object.entries(t).map(([k,v]) => `<b>${k}:</b><span>${v}</span>`).join('')}
                </div></details>`;
            
            item.onclick = (e) => {
                if (e.target.tagName !== 'SUMMARY' && e.target.closest('details') === null) {
                    highlightObjectOnMap(el.type, el.id, item);
                }
            };
            resultsDiv.appendChild(item);
        });
    }

    function boundsFromElement(element) {
        if (!element || !element.bounds) return null;
        const { minlat, minlon, maxlat, maxlon } = element.bounds;
        return L.latLngBounds([minlat, minlon], [maxlat, maxlon]);
    }

    function resolveAreaGeometryTarget(type, id) {
        if (type !== 'area') {
            return { type, id, sourceType: type, sourceId: id };
        }
        const areaId = Number(id);
        if (!Number.isFinite(areaId)) {
            return null;
        }
        if (areaId >= 3600000000) {
            return { type: 'relation', id: areaId - 3600000000, sourceType: 'area', sourceId: id };
        }
        if (areaId >= 2400000000) {
            return { type: 'way', id: areaId - 2400000000, sourceType: 'area', sourceId: id };
        }
        return null;
    }

    async function highlightObjectOnMap(type, id, domElement) {
        document.querySelectorAll('.object-item').forEach(i => i.classList.remove('selected'));
        domElement.classList.add('selected');
        errorBox.style.display = 'none';
        loader.style.display = 'flex';
        resetSelection();

        const target = resolveAreaGeometryTarget(type, id);
        if (!target) {
            errorBox.style.display = 'block';
            errorBox.innerText = "Area kann nicht auf Way/Relation zurückgeführt werden.";
            loader.style.display = 'none';
            return;
        }

        const queryType = target.type;
        const queryId = target.id;

        if (queryType === 'relation') {
            const previewQuery = `[out:json][timeout:180][maxsize:134217728]; relation(${queryId}); out center bb;`;
            try {
                const previewJson = await fetchOverpassJson(previewQuery, {
                    maxWaitMs: MAX_WAIT_GEOM_MS,
                    onWaitMessage: (msg) => {
                        loader.style.display = 'flex';
                        document.getElementById('loading-text').innerText = msg;
                    }
                });
                const relation = (previewJson.elements || []).find(el => el.type === 'relation' && el.id === queryId);
                const bounds = boundsFromElement(relation);
                if (bounds && bounds.isValid()) {
                    if (highlightLayer) map.removeLayer(highlightLayer);
                    highlightLayer = L.rectangle(bounds, {
                        color: '#ff7800',
                        weight: 2,
                        opacity: 0.8,
                        fillColor: '#ff7800',
                        fillOpacity: 0.1
                    }).addTo(map);
                    map.fitBounds(bounds, { padding: [40, 40] });
                    const latSpan = Math.abs(bounds.getNorth() - bounds.getSouth());
                    const lonSpan = Math.abs(bounds.getEast() - bounds.getWest());
                    const areaDeg2 = latSpan * lonSpan;
                    if (areaDeg2 >= RELATION_GEOM_AREA_THRESHOLD_DEG2) {
                        loader.style.display = 'flex';
                        document.getElementById('loading-text').innerText = "Große Geometrie wird geladen...";
                    }
                }
            } catch (err) {
                errorBox.style.display = 'block';
                errorBox.innerText = err.message;
                loader.style.display = 'none';
                document.getElementById('loading-text').innerText = "Fordere Daten an...";
                return;
            }
        }

        const query = `[out:json][timeout:180][maxsize:134217728]; ${queryType}(${queryId}); out geom;`;
        
        try {
            const osmJson = await fetchOverpassJson(query, {
                maxWaitMs: MAX_WAIT_GEOM_MS,
                onWaitMessage: (msg) => {
                    loader.style.display = 'flex';
                    document.getElementById('loading-text').innerText = msg;
                }
            });

            const geojson = osmtogeojson(osmJson);
            geojson.features = geojson.features.filter(f => f.id === `${queryType}/${queryId}`);

            if (geojson.features.length === 0) throw new Error("Keine Geometrie gefunden.");

            selectedObjectData = geojson;
            if (highlightLayer) map.removeLayer(highlightLayer);
            highlightLayer = L.geoJSON(geojson, {
                style: { color: '#ff7800', weight: 4, opacity: 0.8, fillColor: '#ff7800', fillOpacity: 0.2 }
            }).addTo(map);

            const bounds = highlightLayer.getBounds();
            if (bounds.isValid()) map.fitBounds(bounds, { padding: [40, 40] });

            document.getElementById('copyBtn').classList.add('active');
            document.getElementById('downBtn').classList.add('active');

        } catch (err) {
            errorBox.style.display = 'block';
            errorBox.innerText = err.message;
        } finally {
            loader.style.display = 'none';
            document.getElementById('loading-text').innerText = "Fordere Daten an...";
        }
    }

    function resetSelection() {
        selectedObjectData = null;
        document.getElementById('copyBtn').classList.remove('active');
        document.getElementById('downBtn').classList.remove('active');
    }

    async function doExport(action) {
        if (!selectedObjectData) return;
        const btn = action === 'copy' ? document.getElementById('copyBtn') : document.getElementById('downBtn');
        const originalText = btn.innerText;
        const jsonString = JSON.stringify(selectedObjectData, null, 2);

        try {
            if (action === 'copy') {
                await navigator.clipboard.writeText(jsonString);
                btn.innerText = "Kopiert!";
            } else {
                const blob = new Blob([jsonString], {type: "application/json"});
                const a = document.createElement('a');
                const name = selectedObjectData.features[0].id.replace('/', '_');
                a.href = URL.createObjectURL(blob);
                a.download = `${name}.geojson`;
                a.click();
                btn.innerText = "Download OK";
            }
        } catch (e) { alert("Export-Fehler"); }
        setTimeout(() => btn.innerText = originalText, 2000);
    }
</script>
</body>
</html>
