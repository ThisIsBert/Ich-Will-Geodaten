<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSM Explorer - Retry on Busy</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.4/osmtogeojson.js"></script>

    <style>
        body { margin: 0; padding: 0; display: flex; font-family: 'Segoe UI', sans-serif; height: 100vh; background: #f0f2f5; overflow: hidden; }
        #map { flex-grow: 1; height: 100%; }
        #sidebar { width: 420px; display: flex; flex-direction: column; background: white; border-left: 1px solid #ccc; box-shadow: -2px 0 10px rgba(0,0,0,0.1); z-index: 1001; position: relative; }
        .sidebar-header { padding: 20px; border-bottom: 2px solid #eee; }
        .sidebar-content { flex-grow: 1; overflow-y: auto; padding: 15px; }
        
        #loading-overlay { display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.85); z-index: 2000; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 40px; height: 40px; border-radius: 50%; border-left-color: #007bff; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .export-bar { display: flex; gap: 10px; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; }
        .export-bar button { flex: 1; padding: 10px; border: none; border-radius: 5px; background: #007bff; color: white; font-weight: bold; cursor: pointer; opacity: 0.3; pointer-events: none; transition: 0.2s; }
        .export-bar button.active { opacity: 1; pointer-events: auto; }
        .export-bar button#copyBtn.active { background: #28a745; }

        .object-item { border: 1px solid #ddd; border-radius: 8px; margin-bottom: 10px; padding: 12px; cursor: pointer; font-size: 13px; }
        .object-item.selected { border: 2px solid #ff7800; background: #fff4e6; }
        .object-title { font-weight: bold; color: #333; display: block; margin-bottom: 3px; }
        
        details { font-size: 11px; margin-top: 5px; color: #555; }
        summary { cursor: pointer; color: #007bff; outline: none; }
        .tag-grid { display: grid; grid-template-columns: auto 1fr; gap: 3px 8px; padding: 5px; background: #fefefe; border: 1px solid #eee; margin-top: 5px; }

        .error-hint { color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; padding: 10px; border-radius: 4px; font-size: 11px; margin-top: 10px; display: none; white-space: pre-wrap; }
    </style>
</head>
<body>

<div id="map"></div>
<div id="sidebar">
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Fordere Daten an...</div>
    </div>

    <div class="sidebar-header">
        <h3 style="margin:0">OSM Selector</h3>
        <div class="export-bar">
            <button id="copyBtn" onclick="doExport('copy')">ðŸ“‹ Kopieren</button>
            <button id="downBtn" onclick="doExport('download')">ðŸ’¾ Download</button>
        </div>
        <div id="status-error" class="error-hint"></div>
    </div>
    
    <div class="sidebar-content" id="results">
        <p style="text-align:center; color: #888;">Klicke auf die Karte fÃ¼r Objekte in Deutschland.</p>
    </div>
</div>

<script>
    const map = L.map('map').setView([51.1657, 10.4515], 6); 
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
        attribution: 'Â© OpenStreetMap' 
    }).addTo(map);

    let clickMarker = null, highlightLayer = null, selectedObjectData = null;
    const loader = document.getElementById('loading-overlay');
    const errorBox = document.getElementById('status-error');

    map.on('click', function(e) {
        const { lat, lng } = e.latlng;
        if (clickMarker) map.removeLayer(clickMarker);
        clickMarker = L.circleMarker([lat, lng], { color: 'red', radius: 5, fillOpacity: 0.8 }).addTo(map);
        if (highlightLayer) map.removeLayer(highlightLayer);
        errorBox.style.display = 'none';
        resetSelection();
        fetchObjects(lat, lng);
    });

    const OVERPASS_ENDPOINT = 'https://overpass-api.de/api/interpreter';
    const BUSY_HINTS = ["Dispatcher_Client", "too busy", "timeout", "rate limit"];
    const REQUEST_TIMEOUT_MS = 120000;
    const MAX_WAIT_SEARCH_MS = 180000;
    const MAX_WAIT_GEOM_MS = 600000;
    const RETRY_BASE_DELAY_MS = 3000;
    const RETRY_MAX_DELAY_MS = 20000;

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function isBusyResponse(text, status) {
        if ([429, 502, 503, 504].includes(status)) return true;
        const lower = text.toLowerCase();
        return BUSY_HINTS.some(hint => lower.includes(hint.toLowerCase()));
    }

    async function fetchOverpassJson(query, options = {}) {
        const {
            maxWaitMs = 180000,
            requestTimeoutMs = REQUEST_TIMEOUT_MS,
            onWaitMessage = () => {}
        } = options;
        const start = Date.now();
        let attempt = 0;

        while (true) {
            attempt += 1;
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), requestTimeoutMs);
            let text = '';
            let status = 0;

            try {
                const response = await fetch(OVERPASS_ENDPOINT, {
                    method: 'POST',
                    body: new URLSearchParams({ data: query }),
                    signal: controller.signal
                });
                status = response.status;
                text = await response.text();
            } catch (err) {
                if (Date.now() - start >= maxWaitMs) {
                    throw new Error("Die Abfrage dauert zu lange und wurde abgebrochen.");
                }
                const waitMs = Math.min(RETRY_BASE_DELAY_MS * attempt, RETRY_MAX_DELAY_MS);
                onWaitMessage(`Verbindung unterbrochen. Warte ${Math.round(waitMs / 1000)}s...`);
                await sleep(waitMs);
                continue;
            } finally {
                clearTimeout(timeoutId);
            }

            try {
                return JSON.parse(text);
            } catch (err) {
                if (isBusyResponse(text, status)) {
                    if (Date.now() - start >= maxWaitMs) {
                        throw new Error("Die Abfrage dauert zu lange und wurde abgebrochen.");
                    }
                    const waitMs = Math.min(RETRY_BASE_DELAY_MS * attempt, RETRY_MAX_DELAY_MS);
                    onWaitMessage(`Server beschÃ¤ftigt. Warte ${Math.round(waitMs / 1000)}s...`);
                    await sleep(waitMs);
                    continue;
                }
                const cleanError = text.replace(/<\/?[^>]+(>|$)/g, "").trim();
                throw new Error("Server-Fehler:\n" + cleanError.substring(0, 200));
            }
        }
    }

    async function fetchObjects(lat, lon) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = `<p style="text-align:center;">Suche...</p>`;
        const query = `[out:json][timeout:60]; ( nwr(around:45, ${lat}, ${lon}); is_in(${lat}, ${lon})->.a; nwr(pivot.a); ); out tags center;`;

        try {
            const data = await fetchOverpassJson(query, {
                maxWaitMs: MAX_WAIT_SEARCH_MS,
                onWaitMessage: (msg) => {
                    resultsDiv.innerHTML = `<p style="text-align:center;">${msg}</p>`;
                }
            });
            const elements = (data.elements || []).filter(el => el.tags);
            if (elements.length === 0) { resultsDiv.innerHTML = "Nichts gefunden."; return; }
            renderList(elements);
        } catch (err) {
            resultsDiv.innerHTML = "Fehler beim Laden der Liste.";
            errorBox.style.display = 'block';
            errorBox.innerText = err.message;
        }
    }

    function renderList(elements) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';
        elements.forEach(el => {
            const t = el.tags;
            const name = t.name || t.highway || t.amenity || t.building || t.boundary || `ID: ${el.id}`;
            const item = document.createElement('div');
            item.className = 'object-item';
            item.innerHTML = `<span class="object-title">[${el.type.toUpperCase()}] ${name}</span>
                <details><summary>Tags</summary><div class="tag-grid">
                ${Object.entries(t).map(([k,v]) => `<b>${k}:</b><span>${v}</span>`).join('')}
                </div></details>`;
            
            item.onclick = (e) => {
                if (e.target.tagName !== 'SUMMARY' && e.target.closest('details') === null) {
                    highlightObjectOnMap(el.type, el.id, item);
                }
            };
            resultsDiv.appendChild(item);
        });
    }

    async function highlightObjectOnMap(type, id, domElement) {
        document.querySelectorAll('.object-item').forEach(i => i.classList.remove('selected'));
        domElement.classList.add('selected');
        errorBox.style.display = 'none';
        loader.style.display = 'flex';
        resetSelection();

        const query = `[out:json][timeout:180][maxsize:1073741824]; ${type}(${id}); out geom;`;
        
        try {
            const osmJson = await fetchOverpassJson(query, {
                maxWaitMs: MAX_WAIT_GEOM_MS,
                onWaitMessage: (msg) => {
                    loader.style.display = 'flex';
                    document.getElementById('loading-text').innerText = msg;
                }
            });

            const geojson = osmtogeojson(osmJson);
            geojson.features = geojson.features.filter(f => f.id === `${type}/${id}`);

            if (geojson.features.length === 0) throw new Error("Keine Geometrie gefunden.");

            selectedObjectData = geojson;
            if (highlightLayer) map.removeLayer(highlightLayer);
            highlightLayer = L.geoJSON(geojson, {
                style: { color: '#ff7800', weight: 4, opacity: 0.8, fillColor: '#ff7800', fillOpacity: 0.2 }
            }).addTo(map);

            const bounds = highlightLayer.getBounds();
            if (bounds.isValid()) map.fitBounds(bounds, { padding: [40, 40] });

            document.getElementById('copyBtn').classList.add('active');
            document.getElementById('downBtn').classList.add('active');

        } catch (err) {
            errorBox.style.display = 'block';
            errorBox.innerText = err.message;
        } finally {
            loader.style.display = 'none';
            document.getElementById('loading-text').innerText = "Fordere Daten an...";
        }
    }

    function resetSelection() {
        selectedObjectData = null;
        document.getElementById('copyBtn').classList.remove('active');
        document.getElementById('downBtn').classList.remove('active');
    }

    async function doExport(action) {
        if (!selectedObjectData) return;
        const btn = action === 'copy' ? document.getElementById('copyBtn') : document.getElementById('downBtn');
        const originalText = btn.innerText;
        const jsonString = JSON.stringify(selectedObjectData, null, 2);

        try {
            if (action === 'copy') {
                await navigator.clipboard.writeText(jsonString);
                btn.innerText = "Kopiert!";
            } else {
                const blob = new Blob([jsonString], {type: "application/json"});
                const a = document.createElement('a');
                const name = selectedObjectData.features[0].id.replace('/', '_');
                a.href = URL.createObjectURL(blob);
                a.download = `${name}.geojson`;
                a.click();
                btn.innerText = "Download OK";
            }
        } catch (e) { alert("Export-Fehler"); }
        setTimeout(() => btn.innerText = originalText, 2000);
    }
</script>
</body>
</html>
